<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>stats · BayesFitness</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BayesFitness</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">BayesFitness</a></li><li><a class="tocitem" href="../mcmc/">mcmc</a></li><li><a class="tocitem" href="../model/">model</a></li><li class="is-active"><a class="tocitem" href>stats</a></li><li><a class="tocitem" href="../utils/">utils</a></li><li><a class="tocitem" href="../viz/">viz</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>stats</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>stats</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mrazomej/BayesFitness.jl/blob/main/docs/src/stats.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="stats"><a class="docs-heading-anchor" href="#stats">stats</a><a id="stats-1"></a><a class="docs-heading-anchor-permalink" href="#stats" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.stats.beta_prior_mutant-Tuple{Vector}" href="#BayesFitness.stats.beta_prior_mutant-Tuple{Vector}"><code>BayesFitness.stats.beta_prior_mutant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">beta_prior_mutant(neutrals)</code></pre><p>Function to return the vector α̲ for the equivalent of a uniform Dirichlet prior when inferring the relative fitness of a single mutant. Since we use the Beta distribution as the prior when inferring the marginal distribution, this function assigns a <code>1</code> to the mutant parameter and a <code>B̲ - 1</code> to the complement, where <code>B̲</code> is the total number of unique barcodes.</p><p><strong>Arguments</strong></p><ul><li><code>bc_id::Vector{Any}</code>: Vector with the IDs for each barcode</li></ul><p><strong>Returns</strong></p><ul><li><code>α̲::Vector{Float64}</code>: Parameters for Beta prior. Mutant lineage is assigned <code>α = 1</code>. The rest of the lineages are grouped together into a single term with <code>αᴮ = B̲ - 1</code>, i.e., the number of lineages minus the mutant lineage being inferred.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/9c15cab41ce0681c856f806d0569028620160bd8/src/stats.jl#L38-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.stats.dirichlet_prior_neutral-Tuple{Vector{Bool}}" href="#BayesFitness.stats.dirichlet_prior_neutral-Tuple{Vector{Bool}}"><code>BayesFitness.stats.dirichlet_prior_neutral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dirichlet_prior_neutral(neutrals)</code></pre><p>Function to return the vector α̲ for the equivalent of a uniform Dirichlet prior when inferring the population mean fitness with the neutral lineages. </p><p><strong>Arguments</strong></p><ul><li><code>neutrals::Vector{Bool}</code>: Vector indicating which barcodes correspond to neutral lineages and wich to mutant lineages.</li></ul><p><strong>Returns</strong></p><ul><li><code>α̲::Vector{Float64}</code>: Parameters for uniform Dirichlet prior. All lineages lineages are assigned α = 1. The mutant lineages are grouped together into a single term with αᴹ = ∑ₘ α, i.e., the number of non-neutral lineages.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/9c15cab41ce0681c856f806d0569028620160bd8/src/stats.jl#L18-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.stats.freq_mutant_ppc-Tuple{DataFrames.AbstractDataFrame, Union{AbstractString, Symbol}, Union{AbstractString, Symbol}, Union{AbstractString, Symbol}}" href="#BayesFitness.stats.freq_mutant_ppc-Tuple{DataFrames.AbstractDataFrame, Union{AbstractString, Symbol}, Union{AbstractString, Symbol}, Union{AbstractString, Symbol}}"><code>BayesFitness.stats.freq_mutant_ppc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freq_mutant_ppc(df, varname_mut, varname_mean, varname_freq)</code></pre><p>Function to compute the <strong>posterior predictive checks</strong> for the barcode frequency for adaptive mutants. Our model predicts the frequency at time <span>$t+1$</span> based on the frequency at time <span>$t$</span> as</p><p class="math-container">\[    f_{t+1}^{(m)} = f_{t}^{(m)} 
    \exp\left[ \left( s^{(m)} - \bar{s}_t \right) \tau \right],\]</p><p>where <span>$s^{(m)}$</span> is the mutant relative fitness, <span>$\bar{s}_t$</span> is the population mean fitness between time <span>$t$</span> and <span>$t+1$</span>, and <span>$\tau$</span> is the time interval between time <span>$t$</span> and <span>$t+1$</span>. This funciton computes the frequency for each of the MCMC samples in the <code>chain</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrames.DataFrame</code>: Dataframe containing the MCMC samples for the variables needed to compute the posterior predictive checks. The dataframe should have MCMC samples for<ul><li>mutant relative fitness values.</li><li>population mean fitness values. NOTE: The number of columns containing population mean fitness values determines the number of datapoints where the ppc are evaluated.</li><li>mutant initial frequency.</li></ul></li><li><code>varname_mut::Union{Symbol, AbstractString}</code>: Variable name for the mutant   relative fitness in the data frame.</li><li><code>varname_mean::Union{Symbol, AbstractString}</code>: Variable name pattern for <em>all</em> population mean fitness. All columns in the dataframe should contain this pattern and the sorting of these names must correspond to the sorting of the time points.</li><li><code>varname_freq::Union{Symbol, AbstractString}</code>: Variable name for initial mutant barcode frequencies.</li></ul><p><strong>Returns</strong></p><ul><li><code>fₜ₊₁ = fₜ × exp(s⁽ᵐ⁾ - s̅ₜ)::Array{Float64}</code>: Evaluation of the frequency posterior predictive checks at all times for each MCMC sample. The dimensions of the output are (n<em>samples × n</em>time × n_chains)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/9c15cab41ce0681c856f806d0569028620160bd8/src/stats.jl#L325-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.stats.freq_mutant_ppc-Tuple{MCMCChains.Chains}" href="#BayesFitness.stats.freq_mutant_ppc-Tuple{MCMCChains.Chains}"><code>BayesFitness.stats.freq_mutant_ppc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freq_mutant_ppc(chain, varname_mut, varname_mean)</code></pre><p>Function to compute the <strong>posterior predictive checks</strong> for the barcode frequency for adaptive mutants. Our model predicts the frequency at time <span>$t+1$</span> based on the frequency at time <span>$t$</span> as</p><p class="math-container">\[    f_{t+1}^{(m)} = f_{t}^{(m)} 
    \exp\left[ \left( s^{(m)} - \bar{s}_t \right) \tau \right],\]</p><p>where <span>$s^{(m)}$</span> is the mutant relative fitness, <span>$\bar{s}_t$</span> is the population mean fitness between time <span>$t$</span> and <span>$t+1$</span>, and <span>$\tau$</span> is the time interval between time <span>$t$</span> and <span>$t+1$</span>. This funciton computes the frequency for each of the MCMC samples in the <code>chain</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>chain::MCMCChains.Chains</code>: <code>Turing.jl</code> MCMC chain for the fitness of a single mutant.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>varname_mut::Symbol=Symbol(&quot;s⁽ᵐ⁾&quot;)</code>: Variable name for the mutant relative fitness   in the <code>chain</code> object.</li><li><code>varname_mean::Symbol=Symbol(&quot;s̲ₜ&quot;)</code>: Variable name for <em>all</em> population mean fitness.</li><li><code>freq_mut::Symbol=Symbol(&quot;f̲⁽ᵐ⁾&quot;)</code>: Variable name for <em>all</em> mutant barcode frequencies.</li></ul><p><strong>Returns</strong></p><ul><li><code>fₜ₊₁ = fₜ × exp(s⁽ᵐ⁾ - s̅ₜ)::Array{Float64}</code>: Evaluation of the frequency posterior predictive checks at all times for each MCMC sample. The dimensions of the output are (n<em>samples × n</em>time × n_chains)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/9c15cab41ce0681c856f806d0569028620160bd8/src/stats.jl#L100-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.stats.freq_mutant_ppc_quantile-Tuple{Vector{&lt;:AbstractFloat}, DataFrames.AbstractDataFrame, Union{AbstractString, Symbol}, Union{AbstractString, Symbol}, Union{AbstractString, Symbol}}" href="#BayesFitness.stats.freq_mutant_ppc_quantile-Tuple{Vector{&lt;:AbstractFloat}, DataFrames.AbstractDataFrame, Union{AbstractString, Symbol}, Union{AbstractString, Symbol}, Union{AbstractString, Symbol}}"><code>BayesFitness.stats.freq_mutant_ppc_quantile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freq_mut_ppc_quantile(quantile, df, varname_mut, varname_mean, varname_freq)</code></pre><p>Function to compute the <strong>posterior predictive checks</strong> quantiles for the barcode frequency for adaptive mutants. Our model predicts the frequency at time <span>$t+1$</span> based on the frequency at time <span>$t$</span> as</p><p class="math-container">\[    f_{t+1}^{(m)} = f_{t}^{(m)} 
    \exp\left[ \left( s^{(m)} - \bar{s}_t \right) \tau \right],\]</p><p>where <span>$s^{(m)}$</span> is the mutant relative fitness, <span>$\bar{s}_t$</span> is the population mean fitness between time <span>$t$</span> and <span>$t+1$</span>, and <span>$\tau$</span> is the time interval between time <span>$t$</span> and <span>$t+1$</span>. This funciton computes the frequency for each of the MCMC samples in the <code>chain</code> object, and then extracts the quantiles from these posterior predictive checks.</p><p><strong>Arguments</strong></p><ul><li><code>quantile::Vector{&lt;:AbstractFloat}</code>: List of quantiles to extract from the posterior predictive checks.</li><li><code>df::DataFrames.DataFrame</code>: Dataframe containing the MCMC samples for the</li></ul><p>variables needed to compute the posterior predictive checks. The dataframe should have MCMC samples for</p><ul><li>mutant relative fitness values.</li><li>population mean fitness values. NOTE: The number of columns containing population mean fitness values determines the number of datapoints where the ppc are evaluated.</li><li>mutant initial frequency.</li><li><code>varname_mut::Union{Symbol, AbstractString}</code>: Variable name for the mutant relative fitness in the data frame.</li><li><code>varname_mean::Union{Symbol, AbstractString}</code>: Variable name pattern for <em>all</em></li></ul><p>population mean fitness. All columns in the dataframe should contain this   pattern and the sorting of these names must correspond to the sorting of the   time points.</p><ul><li><code>varname_freq::Union{Symbol, AbstractString}</code>: Variable name for initial mutant barcode frequencies.</li></ul><p><strong>Returns</strong></p><ul><li><code>fₜ₊₁ = fₜ × exp(s⁽ᵐ⁾ - s̅ₜ)::Array{Float64}</code>: Evaluation of the frequency posterior predictive check quantiles at all times for each MCMC sample. The dimensions of the output are (n<em>time × n</em>quantile × 2), where the last dimension is used to store the lower and upper bound of the quantile. For example, if the quantile is 0.95, the third dimension stores the 0.025 and the 0.975 quantile that encompass the requested 0.95 quantile.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/9c15cab41ce0681c856f806d0569028620160bd8/src/stats.jl#L387-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.stats.freq_mutant_ppc_quantile-Tuple{Vector{&lt;:AbstractFloat}, MCMCChains.Chains}" href="#BayesFitness.stats.freq_mutant_ppc_quantile-Tuple{Vector{&lt;:AbstractFloat}, MCMCChains.Chains}"><code>BayesFitness.stats.freq_mutant_ppc_quantile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freq_mut_ppc_quantile(quantile, chain, varname_mut, varname_mean, freq_mut)</code></pre><p>Function to compute the <strong>posterior predictive checks</strong> quantiles for the barcode frequency for adaptive mutants. Our model predicts the frequency at time <span>$t+1$</span> based on the frequency at time <span>$t$</span> as</p><p class="math-container">\[    f_{t+1}^{(m)} = f_{t}^{(m)} 
    \exp\left[ \left( s^{(m)} - \bar{s}_t \right) \tau \right],\]</p><p>where <span>$s^{(m)}$</span> is the mutant relative fitness, <span>$\bar{s}_t$</span> is the population mean fitness between time <span>$t$</span> and <span>$t+1$</span>, and <span>$\tau$</span> is the time interval between time <span>$t$</span> and <span>$t+1$</span>. This funciton computes the frequency for each of the MCMC samples in the <code>chain</code> object, and then extracts the quantiles from these posterior predictive checks.</p><p><strong>Arguments</strong></p><ul><li><code>quantile::Vector{&lt;:AbstractFloat}</code>: List of quantiles to extract from the posterior predictive checks.</li><li><code>chain::MCMCChains.Chains</code>: <code>Turing.jl</code> MCMC chain for the fitness of a single   mutant.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>varname_mut::Symbol=Symbol(&quot;s⁽ᵐ⁾&quot;)</code>: Variable name for the mutant relative   fitness in the <code>chain</code> object.</li><li><code>varname_mean::Symbol=Symbol(&quot;s̲ₜ&quot;)</code>: Variable name for <em>all</em> population mean   fitness.</li><li><code>freq_mut::Symbol=Symbol(&quot;f̲⁽ᵐ⁾&quot;)</code>: Variable name for <em>all</em> mutant barcode   frequencies.</li></ul><p><strong>Returns</strong></p><ul><li><code>fₜ₊₁ = fₜ × exp(s⁽ᵐ⁾ - s̅ₜ)::Array{Float64}</code>: Evaluation of the frequency posterior predictive check quantiles at all times for each MCMC sample. The dimensions of the output are (n<em>time × n</em>quantile × 2), where the last dimension is used to store the lower and upper bound of the quantile. For example, if the quantile is 0.95, the third dimension stores the 0.025 and the 0.975 quantile that encompass the requested 0.95 quantile.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/9c15cab41ce0681c856f806d0569028620160bd8/src/stats.jl#L186-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.stats.gaussian_prior_mean_fitness-Tuple{DataFrames.AbstractDataFrame}" href="#BayesFitness.stats.gaussian_prior_mean_fitness-Tuple{DataFrames.AbstractDataFrame}"><code>BayesFitness.stats.gaussian_prior_mean_fitness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaussian_prior_mean_fitness(data)</code></pre><p>Function that fits Gaussian (normal) distributions to MCMC traces from the population mean fitness s̄ₜ. These Gaussians are then used during the mutant relative fitness inference.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrames.AbstractDataFrame</code>: DataFrame containing the MCMC samples for each of the inferred population mean fitness values, one inferred mean fitness per column.</li></ul><p><strong>Returns</strong></p><ul><li><code>µ::Vector{Float64}</code>: Vector encoding the mean values of the Gaussian distributions.</li><li><code>σ::Vector{Float64}</code>: Vector encoding the standard deviation values of the Gaussian distributions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/9c15cab41ce0681c856f806d0569028620160bd8/src/stats.jl#L61-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.stats.logfreqratio_neutral_ppc_quantile-Tuple{Vector{&lt;:AbstractFloat}, DataFrames.AbstractDataFrame}" href="#BayesFitness.stats.logfreqratio_neutral_ppc_quantile-Tuple{Vector{&lt;:AbstractFloat}, DataFrames.AbstractDataFrame}"><code>BayesFitness.stats.logfreqratio_neutral_ppc_quantile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logfreqratio_neutral_ppc_quantile(quantile, df)</code></pre><p>Function to compute the <strong>posterior predictive checks</strong> for the barcode log frequency ratio for neutral lineages. Our model predicts the frequency for neutral lineages at time <span>$t+1$</span> based on the frequency at time <span>$t$</span> as</p><p class="math-container">\[    f_{t+1}^{(n)} = f_{t}^{(n)} 
    \exp\left[  - \bar{s}_t \tau \right],\]</p><p>where <span>$\bar{s}_t$</span> is the population mean fitness between time <span>$t$</span> and <span>$t+1$</span>, and <span>$\tau$</span> is the time interval between time <span>$t$</span> and <span>$t+1$</span>. Solving for the mean fitness results in</p><p class="math-container">\[    \frac{1}{\tau} \log \frac{f_{t+1}^{(n)}}{f_{t}^{(n)}} = - \bar{s}_t.\]</p><p>This function computes the quantiles of the log frequency ration for the neutral lineages, given the MCMC samples of the population mean fitness.</p><p><strong>Arguments</strong></p><ul><li><code>quantile::Vector{&lt;:AbstractFloat}</code>: List of quantiles to extract from the posterior predictive checks. </li></ul><p>-<code>df::DataFrames.DataFrame</code>: DataFrame containing all population mean fitness samples⸺multiple chains must be collapsed into a single column⸺one time point per column. Note: we recommend using the <code>var_jld2_to_df</code> from the <code>utils</code> module to build this dataframe.</p><p><strong>Returns</strong></p><ul><li><code>log(fₜ₊₁ / fₜ) = - s̅ₜ::Array{Float64}</code>: Evaluation of the log frequency ratio posterior predictive checks at all times for each MCMC sample. The dimensions of the output are (n<em>time × n</em>quantile × 2), where the last dimension is used to store the lower and upper bound of the quantile. For example, if the quantile is 0.95, the third dimension stores the 0.025 and the 0.975 quantile that encompass the requested 0.95 quantile.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/9c15cab41ce0681c856f806d0569028620160bd8/src/stats.jl#L261-L297">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model/">« model</a><a class="docs-footer-nextpage" href="../utils/">utils »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 13 April 2023 06:23">Thursday 13 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
