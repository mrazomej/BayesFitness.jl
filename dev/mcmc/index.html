<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>mcmc · BayesFitness</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BayesFitness</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">BayesFitness</a></li><li class="is-active"><a class="tocitem" href>mcmc</a></li><li><a class="tocitem" href="../model/">model</a></li><li><a class="tocitem" href="../stats/">stats</a></li><li><a class="tocitem" href="../utils/">utils</a></li><li><a class="tocitem" href="../viz/">viz</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>mcmc</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>mcmc</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mrazomej/BayesFitness.jl/blob/main/docs/src/mcmc.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="mcmc"><a class="docs-heading-anchor" href="#mcmc">mcmc</a><a id="mcmc-1"></a><a class="docs-heading-anchor-permalink" href="#mcmc" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.mcmc.mcmc_joint_fitness-Tuple{}" href="#BayesFitness.mcmc.mcmc_joint_fitness-Tuple{}"><code>BayesFitness.mcmc.mcmc_joint_fitness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mcmc_joint_fitness(; kwargs)</code></pre><p>Function to sample the joint posterior distribution for the fitness value of all mutant and neutral linages given a time-series barcode count.</p><p>This function expects the data in a <strong>tidy</strong> format. This means that every row represents <strong>a single observation</strong>. For example, if we measure barcode <code>i</code> in 4 different time points, each of these four measurements gets an individual row. Furthermore, measurements of barcode <code>j</code> over time also get their own individual rows.</p><p>The <code>DataFrame</code> must contain at least the following columns:</p><ul><li><code>id_col</code>: Column identifying the ID of the barcode. This can the barcode sequence, for example.</li><li><code>time_col</code>: Column defining the measurement time point.</li><li><code>count_col</code>: Column with the raw barcode count.</li><li><code>neutral_col</code>: Column indicating whether the barcode is from a neutral lineage or not.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>data::DataFrames.AbstractDataFrame</code>: <strong>Tidy dataframe</strong> with the data to be</li></ul><p>used to sample from the population mean fitness posterior distribution.</p><ul><li><code>n_walkers::Int</code>: Number of walkers (chains) for the MCMC sample.</li><li><code>n_steps::Int</code>: Number of steps to take.</li><li><code>outputname::String</code>: String to be used to name the <code>.jld2</code> output file.</li><li><code>model::Function</code>: <code>Turing.jl</code> model defining the posterior distribution from which to sample (see <code>BayesFitness.model</code> module). This function must take as the first four inputs the following:<ul><li><code>R̲̲⁽ⁿ⁾::Matrix{Int64}</code>: <code>T × N</code> matrix where <code>T</code> is the number of time points in the data set and <code>N</code> is the number of neutral lineage barcodes. Each column represents the barcode count trajectory for a single neutral lineage.  <strong>NOTE</strong>: The model assumes the rows are sorted in order of increasing time.</li><li><code>R̲̲⁽ᵐ⁾::Matrix{Int64}</code>: <code>T × M</code> matrix where <code>T</code> is the number of time points in the data set and <code>M</code> is the number of mutant lineage barcodes. Each column represents the barcode count trajectory for a single mutant lineage. <strong>NOTE</strong>: The model assumes the rows are sorted in order of increasing time.</li><li><code>R̲̲::Matrix{Int64}</code>:: <code>T × B</code> matrix, where <code>T</code> is the number of time points in the data set and <code>B</code> is the number of barcodes. Each column represents the barcode count trajectory for a single lineage. <strong>NOTE</strong>: This matrix <strong>must</strong> be equivalent to <code>hcat(R̲̲⁽ⁿ⁾, R̲̲⁽ᵐ⁾)</code>. The reason it is an independent input parameter is to avoid the <code>hcat</code> computation within the <code>Turing</code> model.</li><li><code>n̲ₜ::Vector{Int64}</code>: Vector with the total number of barcode counts for each time point. <strong>NOTE</strong>: This vector <strong>must</strong> be equivalent to computing <code>vec(sum(R̲̲, dims=2))</code>. The reason it is an independent input parameter is to avoid the <code>sum</code> computation within the <code>Turing</code> model.</li></ul></li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>model_kwargs::Dict=Dict()</code>: Extra keyword arguments to be passed to the <code>model</code> function.</li><li><code>id_col::Symbol=:barcode</code>: Name of the column in <code>data</code> containing the barcode   identifier. The column may contain any type of entry.</li><li><code>time_col::Symbol=:time</code>: Name of the column in <code>data</code> defining the time point at which measurements were done. The column may contain any type of entry as long as <code>sort</code> will resulted in time-ordered names.</li><li><code>count_col::Symbol=:count</code>: Name of the column in <code>data</code> containing the raw barcode count. The column must contain entries of type <code>Int64</code>.</li><li><code>neutral_col::Symbol=:neutral</code>: Name of the column in <code>data</code> defining whether the barcode belongs to a neutral lineage or not. The column must contain entries of type <code>Bool</code>.</li><li><code>rm_T0::Bool=false</code>: Optional argument to remove the first time point from the inference. Commonly, the data from this first time point is of much lower quality. Therefore, removing this first time point might result in a better inference.</li><li><code>sampler::Turing.Inference.InferenceAlgorithm=Turing.NUTS(0.65)</code>: MCMC sampler to be used.</li><li><code>ensemble::Turing.AbstractMCMC.AbstractMCMCEnsemble=Turing.MCMCSerial()</code>:</li></ul><p>Sampling modality to be used. Options are:     - <code>Turing.MCMCSerial()</code>     - <code>Turing.MCMCThreads()</code>     - <code>Turing.MCMCDistributed()</code></p><ul><li><code>verbose::Bool=true</code>: Boolean indicating if the function should print partial progress to the screen or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/f7e06ba0f40b1df565d8ffcb85428e158c79ad9f/src/mcmc.jl#L546-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.mcmc.mcmc_joint_fitness_hierarchical_replicates-Tuple{}" href="#BayesFitness.mcmc.mcmc_joint_fitness_hierarchical_replicates-Tuple{}"><code>BayesFitness.mcmc.mcmc_joint_fitness_hierarchical_replicates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mcmc_joint_fitness(; kwargs)</code></pre><p>Function to sample the joint posterior distribution for the fitness value of all mutant and neutral linages given a time-series barcode count.</p><p>This function expects the data in a <strong>tidy</strong> format. This means that every row represents <strong>a single observation</strong>. For example, if we measure barcode <code>i</code> in 4 different time points, each of these four measurements gets an individual row. Furthermore, measurements of barcode <code>j</code> over time also get their own individual rows.</p><p>The <code>DataFrame</code> must contain at least the following columns:</p><ul><li><code>id_col</code>: Column identifying the ID of the barcode. This can the barcode sequence, for example.</li><li><code>time_col</code>: Column defining the measurement time point.</li><li><code>count_col</code>: Column with the raw barcode count.</li><li><code>neutral_col</code>: Column indicating whether the barcode is from a neutral lineage or not.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>data::DataFrames.AbstractDataFrame</code>: <strong>Tidy dataframe</strong> with the data to be</li></ul><p>used to sample from the population mean fitness posterior distribution.</p><ul><li><code>n_walkers::Int</code>: Number of walkers (chains) for the MCMC sample.</li><li><code>n_steps::Int</code>: Number of steps to take.</li><li><code>outputname::String</code>: String to be used to name the <code>.jld2</code> output file.</li><li><code>model::Function</code>: <code>Turing.jl</code> model defining the posterior distribution from which to sample (see <code>BayesFitness.model</code> module). This function must take as the first four inputs the following:<ul><li><code>R̲̲⁽ⁿ⁾::Matrix{Int64}</code>: <code>T × N</code> matrix where <code>T</code> is the number of time points in the data set and <code>N</code> is the number of neutral lineage barcodes. Each column represents the barcode count trajectory for a single neutral lineage.  <strong>NOTE</strong>: The model assumes the rows are sorted in order of increasing time.</li><li><code>R̲̲⁽ᵐ⁾::Matrix{Int64}</code>: <code>T × M</code> matrix where <code>T</code> is the number of time points in the data set and <code>M</code> is the number of mutant lineage barcodes. Each column represents the barcode count trajectory for a single mutant lineage. <strong>NOTE</strong>: The model assumes the rows are sorted in order of increasing time.</li><li><code>R̲̲::Matrix{Int64}</code>:: <code>T × B</code> matrix, where <code>T</code> is the number of time points in the data set and <code>B</code> is the number of barcodes. Each column represents the barcode count trajectory for a single lineage. <strong>NOTE</strong>: This matrix <strong>must</strong> be equivalent to <code>hcat(R̲̲⁽ⁿ⁾, R̲̲⁽ᵐ⁾)</code>. The reason it is an independent input parameter is to avoid the <code>hcat</code> computation within the <code>Turing</code> model.</li><li><code>n̲ₜ::Vector{Int64}</code>: Vector with the total number of barcode counts for each time point. <strong>NOTE</strong>: This vector <strong>must</strong> be equivalent to computing <code>vec(sum(R̲̲, dims=2))</code>. The reason it is an independent input parameter is to avoid the <code>sum</code> computation within the <code>Turing</code> model.</li></ul></li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>model_kwargs::Dict=Dict()</code>: Extra keyword arguments to be passed to the <code>model</code> function.</li><li><code>id_col::Symbol=:barcode</code>: Name of the column in <code>data</code> containing the barcode   identifier. The column may contain any type of entry.</li><li><code>time_col::Symbol=:time</code>: Name of the column in <code>data</code> defining the time point at which measurements were done. The column may contain any type of entry as long as <code>sort</code> will resulted in time-ordered names.</li><li><code>count_col::Symbol=:count</code>: Name of the column in <code>data</code> containing the raw barcode count. The column must contain entries of type <code>Int64</code>.</li><li><code>neutral_col::Symbol=:neutral</code>: Name of the column in <code>data</code> defining whether the barcode belongs to a neutral lineage or not. The column must contain entries of type <code>Bool</code>.</li><li><code>rm_T0::Bool=false</code>: Optional argument to remove the first time point from the inference. Commonly, the data from this first time point is of much lower quality. Therefore, removing this first time point might result in a better inference.</li><li><code>sampler::Turing.Inference.InferenceAlgorithm=Turing.NUTS(0.65)</code>: MCMC sampler to be used.</li><li><code>ensemble::Turing.AbstractMCMC.AbstractMCMCEnsemble=Turing.MCMCSerial()</code>:</li></ul><p>Sampling modality to be used. Options are:     - <code>Turing.MCMCSerial()</code>     - <code>Turing.MCMCThreads()</code>     - <code>Turing.MCMCDistributed()</code></p><ul><li><code>verbose::Bool=true</code>: Boolean indicating if the function should print partial progress to the screen or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/f7e06ba0f40b1df565d8ffcb85428e158c79ad9f/src/mcmc.jl#L1000-L1076">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.mcmc.mcmc_mean_fitness-Tuple{}" href="#BayesFitness.mcmc.mcmc_mean_fitness-Tuple{}"><code>BayesFitness.mcmc.mcmc_mean_fitness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mcmc_mean_fitness(; kwargs)</code></pre><p>Function to sample the posterior distribution of the population mean fitness for a series of pairs of time points. This function expects the data in a <strong>tidy</strong> format. This means that every row represents <strong>a single observation</strong>. For example, if we measure barcode <code>i</code> in 4 different time points, each of these four measurements gets an individual row. Furthermore, measurements of barcode <code>j</code> over time also get their own individual rows.</p><p>The <code>DataFrame</code> must contain at least the following columns:</p><ul><li><code>id_col</code>: Column identifying the ID of the barcode. This can the barcode sequence, for example.</li><li><code>time_col</code>: Column defining the measurement time point.</li><li><code>count_col</code>: Column with the raw barcode count.</li><li><code>neutral_col</code>: Column indicating whether the barcode is from a neutral lineage or not.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>data::DataFrames.AbstractDataFrame</code>: <strong>Tidy dataframe</strong> with the data to be used to sample from the population mean fitness posterior distribution.</li><li><code>n_walkers::Int</code>: Number of walkers (chains) for the MCMC sample.</li><li><code>n_steps::Int</code>: Number of steps to take.</li><li><code>outputdir::String</code>: Directory where the output <code>.jld2</code> files containing the MCMC chains should be stored.</li><li><code>outputname::String</code>: Common pattern for all <code>.jld2</code> output files. The output files of this function will be named as</li></ul><pre><code class="nohighlight hljs">$(outputdir)/$(outputname)_$(t)-$(t+1).jld</code></pre><p>where <code>t</code> and <code>t+1</code> indicate the time points used during the inference.</p><ul><li><code>model::Function</code>: <code>Turing.jl</code> model defining the posterior distribution from which to sample (see <code>BayesFitness.model</code> module). This function must take as the first two inputs the following:<ul><li><code>r̲ₜ::Vector{Int64}</code>: Raw counts for <strong>neutral</strong> lineages and the cumulative counts for mutant lineages at time <code>t</code>. NOTE: The last entry of the array must be the sum of all of the counts from mutant lineages.</li><li><code>r̲ₜ₊₁::Vector{Int64}</code>: Raw counts for <strong>neutral</strong> lineages and the cumulative counts for mutant lineages at time <code>t + 1</code>. NOTE: The last entry of the array must be the sum of all of the counts from mutant lineages. </li></ul></li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>model_kwargs::Dict=Dict()</code>: Extra keyword arguments to be passed to the <code>model</code> function.</li><li><code>id_col::Symbol=:barcode</code>: Name of the column in <code>data</code> containing the barcode   identifier. The column may contain any type of entry.</li><li><code>time_col::Symbol=:time</code>: Name of the column in <code>data</code> defining the time point at which measurements were done. The column may contain any type of entry as long as <code>sort</code> will resulted in time-ordered names.</li><li><code>count_col::Symbol=:count</code>: Name of the column in <code>data</code> containing the raw barcode count. The column must contain entries of type <code>Int64</code>.</li><li><code>neutral_col::Symbol=:neutral</code>: Name of the column in <code>data</code> defining whether the barcode belongs to a neutral lineage or not. The column must contain entries of type <code>Bool</code>.</li><li><code>rm_T0::Bool=false</code>: Optional argument to remove the first time point from the inference. Commonly, the data from this first time point is of much lower quality. Therefore, removing this first time point might result in a better inference.</li><li><code>suppress_output::Bool=false</code>: Boolean indicating if the screen output of <code>Turing.jl</code> must be actively suppressed.</li><li><code>sampler::Turing.Inference.InferenceAlgorithm=Turing.NUTS(0.65)</code>: MCMC sampler to be used.</li><li><code>multithread::Bool=true</code>: Boolean indicating if the chains should be run in parallel.</li><li><code>verbose::Bool=true</code>: Boolean indicating if the function should print partial progress to the screen or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/f7e06ba0f40b1df565d8ffcb85428e158c79ad9f/src/mcmc.jl#L28-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.mcmc.mcmc_mutant_fitness-Tuple{}" href="#BayesFitness.mcmc.mcmc_mutant_fitness-Tuple{}"><code>BayesFitness.mcmc.mcmc_mutant_fitness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mcmc_mutant_fitness(; kwargs)</code></pre><p>Function to sample the posterior distribution of mutant lineages relative fitness given a time-series barcode count. </p><p>This function expects the data in a <strong>tidy</strong> format. This means that every row represents <strong>a single observation</strong>. For example, if we measure barcode <code>i</code> in 4 different time points, each of these four measurements gets an individual row. Furthermore, measurements of barcode <code>j</code> over time also get their own individual rows.</p><p>The <code>DataFrame</code> must contain at least the following columns:</p><ul><li><code>id_col</code>: Column identifying the ID of the barcode. This can the barcode sequence, for example.</li><li><code>time_col</code>: Column defining the measurement time point.</li><li><code>count_col</code>: Column with the raw barcode count.</li><li><code>neutral_col</code>: Column indicating whether the barcode is from a neutral lineage or not.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>data::DataFrames.AbstractDataFrame</code>: <strong>Tidy dataframe</strong> with the data to be used to sample from the population mean fitness posterior distribution.</li><li><code>n_walkers::Int</code>: Number of walkers (chains) for the MCMC sample.</li><li><code>n_steps::Int</code>: Number of steps to take.</li><li><code>outputdir::String</code>: Directory where the output <code>.jld2</code> files containing the MCMC chains should be stored.</li><li><code>outputname::String</code>: Common pattern for all <code>.jld2</code> output files. The output files of this function will be named as</li></ul><pre><code class="nohighlight hljs">$(outputdir)/$(outputname)_$(mutant_id).jld</code></pre><p>where <code>t</code> and <code>t+1</code> indicate the time points used during the inference.</p><ul><li><code>model::Function</code>: <code>Turing.jl</code> model defining the posterior distribution from which to sample (see <code>BayesFitness.model</code> module). This function must take as the first two inputs the following:<ul><li><code>r̲ₜ::Vector{Int64}</code>: Raw counts for <strong>neutral</strong> lineages and the cumulative counts for mutant lineages at time <code>t</code>. NOTE: The last entry of the array must be the sum of all of the counts from mutant lineages.</li><li><code>r̲ₜ₊₁::Vector{Int64}</code>: Raw counts for <strong>neutral</strong> lineages and the cumulative counts for mutant lineages at time <code>t + 1</code>. NOTE: The last entry of the array must be the sum of all of the counts from mutant lineages. </li></ul></li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>model_kwargs::Dict=Dict()</code>: Extra keyword arguments to be passed to the <code>model</code> function.</li><li><code>id_col::Symbol=:barcode</code>: Name of the column in <code>data</code> containing the barcode   identifier. The column may contain any type of entry.</li><li><code>time_col::Symbol=:time</code>: Name of the column in <code>data</code> defining the time point at which measurements were done. The column may contain any type of entry as long as <code>sort</code> will resulted in time-ordered names.</li><li><code>count_col::Symbol=:count</code>: Name of the column in <code>data</code> containing the raw barcode count. The column must contain entries of type <code>Int64</code>.</li><li><code>neutral_col::Symbol=:neutral</code>: Name of the column in <code>data</code> defining whether the barcode belongs to a neutral lineage or not. The column must contain entries of type <code>Bool</code>.</li><li><code>rm_T0::Bool=false</code>: Optional argument to remove the first time point from the inference. Commonly, the data from this first time point is of much lower quality. Therefore, removing this first time point might result in a better inference.</li><li><code>suppress_output::Bool=false</code>: Boolean indicating if the screen output of <code>Turing.jl</code> must be actively suppressed.</li><li><code>sampler::Turing.Inference.InferenceAlgorithm=Turing.NUTS(0.65)</code>: MCMC sampler to be used.</li><li><code>multithread_chain::Bool=false</code>: Boolean indicating if the chains should be run in parallel.</li><li><code>multithread_mutant::Bool=false</code>: Boolean indicating if the chains should be run in parallel. NOTE: Only one <code>multithread_</code> option can be true at any point.</li><li><code>verbose::Bool=true</code>: Boolean indicating if the function should print partial progress to the screen or not.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/f7e06ba0f40b1df565d8ffcb85428e158c79ad9f/src/mcmc.jl#L263-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.mcmc.mcmc_single_fitness-Tuple{}" href="#BayesFitness.mcmc.mcmc_single_fitness-Tuple{}"><code>BayesFitness.mcmc.mcmc_single_fitness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mcmc_single_fitness(; kwargs)</code></pre><p>Function to sample the joint posterior distribution for the fitness value of a single mutant barcode and all neutral linages given a time-series barcode count.</p><p>This function expects the data in a <strong>tidy</strong> format. This means that every row represents <strong>a single observation</strong>. For example, if we measure barcode <code>i</code> in 4 different time points, each of these four measurements gets an individual row. Furthermore, measurements of barcode <code>j</code> over time also get their own individual rows.</p><p>The <code>DataFrame</code> must contain at least the following columns:</p><ul><li><code>id_col</code>: Column identifying the ID of the barcode. This can the barcode sequence, for example.</li><li><code>time_col</code>: Column defining the measurement time point.</li><li><code>count_col</code>: Column with the raw barcode count.</li><li><code>neutral_col</code>: Column indicating whether the barcode is from a neutral lineage or not.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>data::DataFrames.AbstractDataFrame</code>: <strong>Tidy dataframe</strong> with the data to be</li></ul><p>used to sample from the population mean fitness posterior distribution.</p><ul><li><code>n_walkers::Int</code>: Number of walkers (chains) for the MCMC sample.</li><li><code>n_steps::Int</code>: Number of steps to take.</li><li><code>outputname::String</code>: String to be used to name the <code>.jld2</code> output file.</li><li><code>model::Function</code>: <code>Turing.jl</code> model defining the posterior distribution from which to sample (see <code>BayesFitness.model</code> module). This function must take as the first four inputs the following:<ul><li><code>R̲̲⁽ⁿ⁾::Matrix{Int64}</code>: <code>T × N</code> matrix where <code>T</code> is the number of time points in the data set and <code>N</code> is the number of neutral lineage barcodes. Each column represents the barcode count trajectory for a single neutral lineage.  <strong>NOTE</strong>: The model assumes the rows are sorted in order of increasing time.</li><li><code>R̲̲⁽ᵐ⁾::Matrix{Int64}</code>: <code>T × M</code> matrix where <code>T</code> is the number of time points in the data set and <code>M</code> is the number of mutant lineage barcodes. Each column represents the barcode count trajectory for a single mutant lineage. <strong>NOTE</strong>: The model assumes the rows are sorted in order of increasing time.</li><li><code>R̲̲::Matrix{Int64}</code>:: <code>T × B</code> matrix, where <code>T</code> is the number of time points in the data set and <code>B</code> is the number of barcodes. Each column represents the barcode count trajectory for a single lineage. <strong>NOTE</strong>: This matrix <strong>must</strong> be equivalent to <code>hcat(R̲̲⁽ⁿ⁾, R̲̲⁽ᵐ⁾)</code>. The reason it is an independent input parameter is to avoid the <code>hcat</code> computation within the <code>Turing</code> model.</li><li><code>n̲ₜ::Vector{Int64}</code>: Vector with the total number of barcode counts for each time point. <strong>NOTE</strong>: This vector <strong>must</strong> be equivalent to computing <code>vec(sum(R̲̲, dims=2))</code>. The reason it is an independent input parameter is to avoid the <code>sum</code> computation within the <code>Turing</code> model.</li></ul></li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>model_kwargs::Dict=Dict()</code>: Extra keyword arguments to be passed to the <code>model</code> function.</li><li><code>id_col::Symbol=:barcode</code>: Name of the column in <code>data</code> containing the barcode   identifier. The column may contain any type of entry.</li><li><code>time_col::Symbol=:time</code>: Name of the column in <code>data</code> defining the time point at which measurements were done. The column may contain any type of entry as long as <code>sort</code> will resulted in time-ordered names.</li><li><code>count_col::Symbol=:count</code>: Name of the column in <code>data</code> containing the raw barcode count. The column must contain entries of type <code>Int64</code>.</li><li><code>neutral_col::Symbol=:neutral</code>: Name of the column in <code>data</code> defining whether the barcode belongs to a neutral lineage or not. The column must contain entries of type <code>Bool</code>.</li><li><code>rm_T0::Bool=false</code>: Optional argument to remove the first time point from the inference. Commonly, the data from this first time point is of much lower quality. Therefore, removing this first time point might result in a better inference.</li><li><code>sampler::Turing.Inference.InferenceAlgorithm=Turing.NUTS(0.65)</code>: MCMC sampler to be used.</li><li><code>ensemble::Turing.AbstractMCMC.AbstractMCMCEnsemble=Turing.MCMCSerial()</code>:</li></ul><p>Sampling modality to be used. Options are:     - <code>Turing.MCMCSerial()</code>     - <code>Turing.MCMCThreads()</code>     - <code>Turing.MCMCDistributed()</code></p><ul><li><code>verbose::Bool=true</code>: Boolean indicating if the function should print partial progress to the screen or not.</li><li><code>multithread::Bool=false</code>: Boolean indicating whether to use <code>Threads.@threads</code> when running the <code>for</code>-loop over all mutants. NOTE: This requires julia to be initialized with multiple threads.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/f7e06ba0f40b1df565d8ffcb85428e158c79ad9f/src/mcmc.jl#L753-L832">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« BayesFitness</a><a class="docs-footer-nextpage" href="../model/">model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 13 July 2023 16:28">Thursday 13 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
