<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>utils · BayesFitness</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BayesFitness</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">BayesFitness</a></li><li><a class="tocitem" href="../mcmc/">mcmc</a></li><li><a class="tocitem" href="../model/">model</a></li><li><a class="tocitem" href="../stats/">stats</a></li><li class="is-active"><a class="tocitem" href>utils</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>utils</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>utils</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mrazomej/BayesFitness.jl/blob/main/docs/src/utils.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="utils"><a class="docs-heading-anchor" href="#utils">utils</a><a id="utils-1"></a><a class="docs-heading-anchor-permalink" href="#utils" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.utils.concat_chains-Tuple{Vector{&lt;:MCMCChains.Chains}, Vector{Symbol}}" href="#BayesFitness.utils.concat_chains-Tuple{Vector{&lt;:MCMCChains.Chains}, Vector{Symbol}}"><code>BayesFitness.utils.concat_chains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`concat_chains(chains, var_pattern, id_str)`</code></pre><p>Function that concatenates multiple <code>MCMCChains.Chains</code> objects into a single one. This function takes a vector of <code>MCMCChains.Chains</code> as inputs, extracts the variables that match the patterns in the array <code>var_pattern</code>, and appends all extracted variables into a single chain adding a pattern of the form <code>[$(id_str)i]</code>, where <code>i</code> is the file number. For example, if two chains contain a variable named <code>var</code>, the new chain returned by this function names them as <code>var[f1]</code> and <code>var[f2]</code> if <code>id_str=f</code>.</p><p>NOTE: All chains must have the same number of samples to be concatenated.</p><p><strong>Arguments</strong></p><ul><li><code>chains::Vector{&lt;:MCMCChains.Chains}</code>: Vector with the chains to be concatenated into a single chain.</li><li><code>var_pattern::Vector{Symbol}</code>: Patterns that variables must follow to be extracted from the chain. For example, if several variables are named <code>var[1]</code>, <code>var[2]</code>, etc, providing a pattern [<code>var</code>] extracts all of them, while providing <code>var[1]</code> extracts only the one that perfectly matches this pattern.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>id_str::String=f</code>: String to be attached to the variable names that identifies the different chains being concatenated. For example, if 4 chains are being concatenated, each repeated variable will be named <code>var[$(id_str)i]</code> to distinguish each of them.</li></ul><p><strong>Returns</strong></p><ul><li><code>MCMCChains.Chains</code>: Chain with the requested variables from multiple files concatenated into a single object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/4d21f704180ee859cb81dc408e3fbce15c2c3d2a/src/utils.jl#L22-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.utils.data2mats-Tuple{DataFrames.AbstractDataFrame}" href="#BayesFitness.utils.data2mats-Tuple{DataFrames.AbstractDataFrame}"><code>BayesFitness.utils.data2mats</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">df2mats(data; kwargs)</code></pre><p>Function that returns the matarices <code>R̲̲⁽ⁿ⁾</code>,  <code>R̲̲⁽ᵐ⁾</code>, and  <code>R̲̲</code> usually taken by the functions in the <code>model.jl</code> module. This function is useful to prototype new models before properly implementing them. The final user most likely won&#39;t need to ever call this function.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrames.AbstractDataFrame</code>: <strong>Tidy dataframe</strong> with the data to be</li></ul><p>used to sample from the population mean fitness posterior distribution.</p><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>id_col::Symbol=:barcode</code>: Name of the column in <code>data</code> containing the barcode   identifier. The column may contain any type of entry.</li><li><code>time_col::Symbol=:time</code>: Name of the column in <code>data</code> defining the time point at which measurements were done. The column may contain any type of entry as long as <code>sort</code> will resulted in time-ordered names.</li><li><code>count_col::Symbol=:count</code>: Name of the column in <code>data</code> containing the raw barcode count. The column must contain entries of type <code>Int64</code>.</li><li><code>neutral_col::Symbol=:neutral</code>: Name of the column in <code>data</code> defining whether the barcode belongs to a neutral lineage or not. The column must contain entries of type <code>Bool</code>.</li><li><code>rm_T0::Bool=false</code>: Optional argument to remove the first time point from the inference. Commonly, the data from this first time point is of much lower quality. Therefore, removing this first time point might result in a better inference.</li></ul><p><strong>Returns</strong></p><ul><li><code>R̲̲⁽ⁿ⁾::Matrix</code>: T × N matrix with the neutral barcodes read counts.</li><li><code>R̲̲⁽ᵐ⁾::Matrix</code>: T × M matrix with the mutant barcodes read counts.</li><li><code>R̲̲::Matrix</code>: T × B matrix with all barcodes read counts.</li><li><code>n̲ₜ::Vector</code>: T-dimensional vector with the total number of reads per time point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/4d21f704180ee859cb81dc408e3fbce15c2c3d2a/src/utils.jl#L286-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.utils.group_split-Tuple{DataFrames.AbstractDataFrame, Int64, Symbol, Symbol}" href="#BayesFitness.utils.group_split-Tuple{DataFrames.AbstractDataFrame, Int64, Symbol, Symbol}"><code>BayesFitness.utils.group_split</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">group_split(data, n_groups, groupby_col, count_col; sort_function)</code></pre><p>Function to split a set of labels into <code>n_group</code> subgroups.</p><p><strong>Arguments</strong></p><ul><li><code>data::DF.AbstractDataFrame</code>: Data to be split into groups. This function   expects a tidy dataframe with at least two columns:<ul><li><code>groupby_col</code>: Column to group entries by. This is commonly the barcode ID that distinguishes different strains.</li><li><code>sort_col</code>: Column with values used to sort the data entries.</li></ul></li><li><code>n_groups::Int</code>: Number of groups in which to split the data</li><li><code>groupby_col::Symbol</code>: Name of column used to group the unique entries in dataset. This is commonly the barcode ID that distinguishes different strains.</li><li><code>sort_col::Symbol</code>: Name of column with quantity used to sort the entries in the dataset. This is commonly the number of barcode counts or frequency.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>sort_function::Function=x -&gt; StatsBase.mean(log.(x .+ 1))</code>: Functio to use on the <code>group-apply-combine</code> routine. The default function computes the mean in log-scale, adding a 1 to avoid computing <code>log(0)</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>groups::Vector{Vector{typeof(data[groupby_col][1])}}</code>: Vectors containing the different groups in which to split the dataset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/4d21f704180ee859cb81dc408e3fbce15c2c3d2a/src/utils.jl#L150-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.utils.group_split_naive_fitness-Tuple{DataFrames.AbstractDataFrame, Int64}" href="#BayesFitness.utils.group_split_naive_fitness-Tuple{DataFrames.AbstractDataFrame, Int64}"><code>BayesFitness.utils.group_split_naive_fitness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">group_split(data, n_groups; kwargs)</code></pre><p>Function to split a set of labels into <code>n_group</code> subgroups sorted by a naive estimate of the fitness value.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrames.AbstractDataFrame</code>: <strong>Tidy dataframe</strong> with the data to be</li></ul><p>used to infer the fitness values on mutants. The <code>DataFrame</code> must contain at least the following columns:     - <code>id_col</code>: Column identifying the ID of the barcode. This can the barcode     sequence, for example.     - <code>time_col</code>: Column defining the measurement time point.     - <code>count_col</code>: Column with the raw barcode count.     - <code>neutral_col</code>: Column indicating whether the barcode is from a neutral     lineage or not.</p><ul><li><code>n_groups::Int</code>: Number of groups in which to split the data.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>id_col::Symbol=:barcode</code>: Name of the column in <code>data</code> containing the barcode   identifier. The column may contain any type of entry.</li><li><code>time_col::Symbol=:time</code>: Name of the column in <code>data</code> defining the time point at which measurements were done. The column may contain any type of entry as long as <code>sort</code> will resulted in time-ordered names.</li><li><code>count_col::Symbol=:count</code>: Name of the column in <code>data</code> containing the raw barcode count. The column must contain entries of type <code>Int64</code>.</li><li><code>neutral_col::Symbol=:neutral</code>: Name of the column in <code>data</code> defining whether the barcode belongs to a neutral lineage or not. The column must contain entries of type <code>Bool</code>.</li><li><code>rm_T0::Bool=false</code>: Optional argument to remove the first time point from the</li></ul><p>inference. Commonly, the data from this first time point is of much lower quality. Therefore, removing this first time point might result in a better inference.</p><ul><li><code>pseudo_count::Int=1</code>: Pseudo count number to add to all counts. This is useful to avoid divisions by zero.</li></ul><p><strong>Returns</strong></p><ul><li><code>groups::Vector{Vector{typeof(data[groupby_col][1])}}</code>: Vectors containing the</li></ul><p>different groups in which to split the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/4d21f704180ee859cb81dc408e3fbce15c2c3d2a/src/utils.jl#L208-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BayesFitness.utils.jld2_concat_chains-Tuple{String, String, Vector{Symbol}}" href="#BayesFitness.utils.jld2_concat_chains-Tuple{String, String, Vector{Symbol}}"><code>BayesFitness.utils.jld2_concat_chains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`jld2_concat_chains(dir, file_patern, chains, var_pattern, id_str)`</code></pre><p>Convenient function that peforms the same concatenation as <code>BayesFitness.utils.concat_chains</code> but giving a directory and a file pattern for <code>jld2</code> files storing the chains. This function reads all files in <code>dir</code> that have the pattern <code>file pattern</code>, obtaining a list of <code>MCMCChains.Chains</code> as inputs. It then extracts the variables that match the patterns in the array <code>var_pattern</code>, and appends all extracted variables into a single chain adding a pattern of the form <code>[$(id_str)i]</code>, where <code>i</code> is the file number. For example, if two chains contain a variable named <code>var</code>, the new chain returned by this function names them as <code>var[f1]</code> and <code>var[f2]</code> if <code>id_str=f</code>.</p><p>NOTE: All chains must have the same number of samples to be concatenated.</p><p><strong>Arguments</strong></p><ul><li><code>dir::String</code>: Directory where file(s) with MCMC chains are stored.</li><li><code>file_pattern::String</code>: Pattern common among all files to process. NOTE: This is use in the <code>Glob.glob</code> command to locate all <code>jld2</code> files from which to extract the chains.</li><li><code>var_pattern::Vector{Symbol}</code>: Patterns that variables must follow to be extracted from the chain. For example, if several variables are named <code>var[1]</code>, <code>var[2]</code>, etc, providing a pattern [<code>var</code>] extracts all of them, while providing <code>var[1]</code> extracts only the one that perfectly matches this pattern.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>id_str::String=f</code>: String to be attached to the variable names that identifies the different chains being concatenated. For example, if 4 chains are being concatenated, each repeated variable will be named <code>var[$(id_str)i]</code> to distinguish each of them.</li></ul><p><strong>Returns</strong></p><ul><li><code>MCMCChains.Chains</code>: Chain with the requested variables from multiple files concatenated into a single object.</li><li><code>chainname::String=&quot;chain&quot;</code>: String defining the dictionary key on the <code>.jld2</code></li></ul><p>file to extract the MCMC chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BayesFitness.jl/blob/4d21f704180ee859cb81dc408e3fbce15c2c3d2a/src/utils.jl#L96-L133">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../stats/">« stats</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 29 July 2023 18:21">Saturday 29 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
